{"comment":"Sstan","footnote":"","findings":[{"severity":"Low","title":"Unsafe ERC20 Operation","description":"\"\"\n        ERC20 operations can be unsafe due to different implementations and vulnerabilities in the standard. To account for this, either use OpenZeppelin's SafeERC20 library or wrap each operation in a require statement. \\n\n        > Additionally, ERC20's approve functions have a known race-condition vulnerability. To account for this, use OpenZeppelin's SafeERC20 library's `safeIncrease` or `safeDecrease` Allowance functions.\n        <details>\n        <summary>Expand Example</summary>\n\n        #### Unsafe Transfer\n\n        ```js\n        IERC20(token).transfer(msg.sender, amount);\n        ```\n\n        #### OpenZeppelin SafeTransfer\n\n        ```js\n        import {SafeERC20} from \\\"openzeppelin/token/utils/SafeERC20.sol\\\";\n        //--snip--\n\n        IERC20(token).safeTransfer(msg.sender, address(this), amount);\n        ```\n                \n        #### Safe Transfer with require statement.\n\n        ```js\n        bool success = IERC20(token).transfer(msg.sender, amount);\n        require(success, \\\"ERC20 transfer failed\\\");\n        ```\n                \n        #### Unsafe TransferFrom\n\n        ```js\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\n        ```\n\n        #### OpenZeppelin SafeTransferFrom\n\n        ```js\n        import {SafeERC20} from \\\"openzeppelin/token/utils/SafeERC20.sol\\\";\n        //--snip--\n\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        ```\n                \n        #### Safe TransferFrom with require statement.\n\n        ```js\n        bool success = IERC20(token).transferFrom(msg.sender, address(this), amount);\n        require(success, \\\"ERC20 transfer failed\\\");\n        ```\n\n        </details>\n        \"\"","gasSavings":null,"category":null,"instances":[{"content":["58:        IERC20(TOKEN_ADDRESS).approve(address(this), _approvalAmount);\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["62:        require(IERC20(TOKEN_ADDRESS).transferFrom(msg.sender, address(this), _amount), \"Transfer Failed\");\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["108:        require(IERC20(TOKEN_ADDRESS).transfer(msg.sender, contractBalance), \"Token transfer failed\");\n"],"loc":["./src/ERC20PaymentNFT.sol"]}]},{"severity":"NonCritical","title":"Constructor should check that all parameters are not 0","description":"Consider adding a require statement to check that all parameters are not 0 in the constructor","gasSavings":null,"category":null,"instances":[{"content":["36:    constructor(\n37:        string memory _name,\n38:        string memory _ticker,\n39:        address _tokenAddress,\n40:        uint256 _mintPrice,\n41:        uint256 _maxSupply,\n42:        uint256 _rate,\n43:        string memory _uri,\n44:        uint64 _maxPublicMint\n45:    )\n46:        ERC721A(_name, _ticker)\n47:        Ownable(msg.sender)\n48:    {\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["36:    constructor(\n37:        string memory _name,\n38:        string memory _ticker,\n39:        address _tokenAddress,\n40:        uint256 _mintPrice,\n41:        uint256 _maxSupply,\n42:        uint256 _rate,\n43:        string memory _uri,\n44:        uint64 _maxPublicMint\n45:    )\n46:        ERC721A(_name, _ticker)\n47:        Ownable(msg.sender)\n48:    {\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["36:    constructor(\n37:        string memory _name,\n38:        string memory _ticker,\n39:        address _tokenAddress,\n40:        uint256 _mintPrice,\n41:        uint256 _maxSupply,\n42:        uint256 _rate,\n43:        string memory _uri,\n44:        uint64 _maxPublicMint\n45:    )\n46:        ERC721A(_name, _ticker)\n47:        Ownable(msg.sender)\n48:    {\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["36:    constructor(\n37:        string memory _name,\n38:        string memory _ticker,\n39:        address _tokenAddress,\n40:        uint256 _mintPrice,\n41:        uint256 _maxSupply,\n42:        uint256 _rate,\n43:        string memory _uri,\n44:        uint64 _maxPublicMint\n45:    )\n46:        ERC721A(_name, _ticker)\n47:        Ownable(msg.sender)\n48:    {\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["36:    constructor(\n37:        string memory _name,\n38:        string memory _ticker,\n39:        address _tokenAddress,\n40:        uint256 _mintPrice,\n41:        uint256 _maxSupply,\n42:        uint256 _rate,\n43:        string memory _uri,\n44:        uint64 _maxPublicMint\n45:    )\n46:        ERC721A(_name, _ticker)\n47:        Ownable(msg.sender)\n48:    {\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["36:    constructor(\n37:        string memory _name,\n38:        string memory _ticker,\n39:        address _tokenAddress,\n40:        uint256 _mintPrice,\n41:        uint256 _maxSupply,\n42:        uint256 _rate,\n43:        string memory _uri,\n44:        uint64 _maxPublicMint\n45:    )\n46:        ERC721A(_name, _ticker)\n47:        Ownable(msg.sender)\n48:    {\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["36:    constructor(\n37:        string memory _name,\n38:        string memory _ticker,\n39:        address _tokenAddress,\n40:        uint256 _mintPrice,\n41:        uint256 _maxSupply,\n42:        uint256 _rate,\n43:        string memory _uri,\n44:        uint64 _maxPublicMint\n45:    )\n46:        ERC721A(_name, _ticker)\n47:        Ownable(msg.sender)\n48:    {\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["36:    constructor(\n37:        string memory _name,\n38:        string memory _ticker,\n39:        address _tokenAddress,\n40:        uint256 _mintPrice,\n41:        uint256 _maxSupply,\n42:        uint256 _rate,\n43:        string memory _uri,\n44:        uint64 _maxPublicMint\n45:    )\n46:        ERC721A(_name, _ticker)\n47:        Ownable(msg.sender)\n48:    {\n"],"loc":["./src/ERC20PaymentNFT.sol"]}]},{"severity":"NonCritical","title":"This error has no parameters, the state of the contract when the revert occured will not be available","description":"Consider adding parameters to the error to provide more context when a transaction fails","gasSavings":null,"category":null,"instances":[{"content":["23:    error MintExceeded();\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["24:    error SupplyExceeded();\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["25:    error TokenDoesNotExist();\n"],"loc":["./src/ERC20PaymentNFT.sol"]}]},{"severity":"NonCritical","title":"Function names should be in camelCase","description":"Ensure that function definitions are declared using camelCase","gasSavings":null,"category":null,"instances":[{"content":["4:    function id(uint256 value) external pure returns (uint256) {\n"],"loc":["./src/Foo.sol"]}]},{"severity":"NonCritical","title":"Consider marking public function External","description":"If a public function is never called internally, it is best practice to mark it as external.","gasSavings":null,"category":null,"instances":[{"content":["94:    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n"],"loc":["./src/ERC20PaymentNFT.sol"]}]},{"severity":"NonCritical","title":"Function parameters should be in camelCase","description":"Ensure that function parameters are declared using camelCase","gasSavings":null,"category":null,"instances":[{"content":["4:    function id(uint256 value) external pure returns (uint256) {\n"],"loc":["./src/Foo.sol"]},{"content":["37:        string memory _name,\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["38:        string memory _ticker,\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["42:        uint256 _rate,\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["43:        string memory _uri,\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["61:    function _transferPaymentToken(uint256 _amount) internal {\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["65:    function mintWithToken(uint256 _amount) external {\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["88:    function setBaseUri(string calldata _uri) external onlyOwner {\n"],"loc":["./src/ERC20PaymentNFT.sol"]}]},{"severity":"Gas","title":"Mark storage variables as `immutable` if they never change after contract initialization.","description":"\n State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. \n The compiler does not reserve a storage slot for these variables, and every occurrence is inlined by the respective value. \n Compared to regular state variables, the gas costs of constant and immutable variables are much lower. For a constant variable, the expression assigned to it is copied to all the places where it is accessed and also re-evaluated each time. This allows for local optimizations. Immutable variables are evaluated once at construction time and their value is copied to all the places in the code where they are accessed. For these values, 32 bytes are reserved, even if they would fit in fewer bytes. Due to this, constant values can sometimes be cheaper than immutable values. \n - Savings: ~2103 \n","gasSavings":null,"category":null,"instances":[{"content":["18:    uint64 public maxPublicMint;\n"],"loc":["./src/ERC20PaymentNFT.sol"]}]},{"severity":"Gas","title":"Cache Storage Variables in Memory","description":"\n  - Savings: ~0 \n","gasSavings":null,"category":null,"instances":[{"content":["78:        live = !live;\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["78:        live = !live;\n"],"loc":["./src/ERC20PaymentNFT.sol"]}]},{"severity":"Gas","title":"Use custom errors instead of string error messages","description":"\n Using custom errors will save you gas, and can be used to provide more information about the error. - Savings: ~57 \n","gasSavings":null,"category":null,"instances":[{"content":["62:        require(IERC20(TOKEN_ADDRESS).transferFrom(msg.sender, address(this), _amount), \"Transfer Failed\");\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["106:        require(contractBalance > 0, \"No funds available for withdrawal.\");\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["108:        require(IERC20(TOKEN_ADDRESS).transfer(msg.sender, contractBalance), \"Token transfer failed\");\n"],"loc":["./src/ERC20PaymentNFT.sol"]}]},{"severity":"Gas","title":"Use assembly for math (add, sub, mul, div)","description":"\n Use assembly for math instead of Solidity. You can check for overflow/underflow in assembly to ensure safety. If using Solidity versions < 0.8.0 and you are using Safemath, you can gain significant gas savings by using assembly to calculate values and checking for overflow/underflow. - Savings: ~60 \n","gasSavings":null,"category":null,"instances":[{"content":["66:        uint256 minted = _numberMinted(msg.sender) + _amount;\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["68:        if (_totalMinted() + _amount > MAX_SUPPLY) revert SupplyExceeded();\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["69:        uint256 mintAmount = rate * _amount;\n"],"loc":["./src/ERC20PaymentNFT.sol"]}]},{"severity":"Gas","title":"Use assembly to write storage values","description":"\n You can save a fair amount of gas by using assembly to write storage values. - Savings: ~66 \n","gasSavings":null,"category":null,"instances":[{"content":["52:        _baseURIString = _uri;\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["53:        maxPublicMint = _maxPublicMint;\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["54:        rate = _rate;\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["78:        live = !live;\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["82:        rate = _newRate;\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["89:        _baseURIString = _uri;\n"],"loc":["./src/ERC20PaymentNFT.sol"]}]},{"severity":"Gas","title":"Mark functions as payable (with discretion)","description":"\n You can mark public or external functions as payable to save gas. Functions that are not payable have additional logic to check if there was a value sent with a call, however, making a function payable eliminates this check. This optimization should be carefully considered due to potentially unwanted behavior when a function does not need to accept ether. - Savings: ~24 \n","gasSavings":null,"category":null,"instances":[{"content":["4:    function id(uint256 value) external pure returns (uint256) {\n"],"loc":["./src/Foo.sol"]},{"content":["65:    function mintWithToken(uint256 _amount) external {\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["77:    function toggleLive() external onlyOwner {\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["81:    function updateRate(uint256 _newRate) external onlyOwner {\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["88:    function setBaseUri(string calldata _uri) external onlyOwner {\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["94:    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n"],"loc":["./src/ERC20PaymentNFT.sol"]},{"content":["103:    function withdrawTokens() external onlyOwner {\n"],"loc":["./src/ERC20PaymentNFT.sol"]}]}]}